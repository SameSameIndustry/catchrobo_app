// Code generated by rclgo-gen. DO NOT EDIT.

package controller_manager_msgs_srv
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <controller_manager_msgs/srv/reload_controller_libraries.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("controller_manager_msgs/ReloadControllerLibraries_Request", ReloadControllerLibraries_RequestTypeSupport)
	typemap.RegisterMessage("controller_manager_msgs/srv/ReloadControllerLibraries_Request", ReloadControllerLibraries_RequestTypeSupport)
}

type ReloadControllerLibraries_Request struct {
	ForceKill bool `yaml:"force_kill"`// Reloading libraries only works if there are no controllers loaded. If thereare still some controllers loaded, the reloading will fail.If this bool is set to true, all loaded controllers will getkilled automatically, and the reloading can succeed.
}

// NewReloadControllerLibraries_Request creates a new ReloadControllerLibraries_Request with default values.
func NewReloadControllerLibraries_Request() *ReloadControllerLibraries_Request {
	self := ReloadControllerLibraries_Request{}
	self.SetDefaults()
	return &self
}

func (t *ReloadControllerLibraries_Request) Clone() *ReloadControllerLibraries_Request {
	c := &ReloadControllerLibraries_Request{}
	c.ForceKill = t.ForceKill
	return c
}

func (t *ReloadControllerLibraries_Request) CloneMsg() types.Message {
	return t.Clone()
}

func (t *ReloadControllerLibraries_Request) SetDefaults() {
	t.ForceKill = false
}

func (t *ReloadControllerLibraries_Request) GetTypeSupport() types.MessageTypeSupport {
	return ReloadControllerLibraries_RequestTypeSupport
}

// ReloadControllerLibraries_RequestPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type ReloadControllerLibraries_RequestPublisher struct {
	*rclgo.Publisher
}

// NewReloadControllerLibraries_RequestPublisher creates and returns a new publisher for the
// ReloadControllerLibraries_Request
func NewReloadControllerLibraries_RequestPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*ReloadControllerLibraries_RequestPublisher, error) {
	pub, err := node.NewPublisher(topic_name, ReloadControllerLibraries_RequestTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &ReloadControllerLibraries_RequestPublisher{pub}, nil
}

func (p *ReloadControllerLibraries_RequestPublisher) Publish(msg *ReloadControllerLibraries_Request) error {
	return p.Publisher.Publish(msg)
}

// ReloadControllerLibraries_RequestSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type ReloadControllerLibraries_RequestSubscription struct {
	*rclgo.Subscription
}

// ReloadControllerLibraries_RequestSubscriptionCallback type is used to provide a subscription
// handler function for a ReloadControllerLibraries_RequestSubscription.
type ReloadControllerLibraries_RequestSubscriptionCallback func(msg *ReloadControllerLibraries_Request, info *rclgo.MessageInfo, err error)

// NewReloadControllerLibraries_RequestSubscription creates and returns a new subscription for the
// ReloadControllerLibraries_Request
func NewReloadControllerLibraries_RequestSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback ReloadControllerLibraries_RequestSubscriptionCallback) (*ReloadControllerLibraries_RequestSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg ReloadControllerLibraries_Request
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, ReloadControllerLibraries_RequestTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &ReloadControllerLibraries_RequestSubscription{sub}, nil
}

func (s *ReloadControllerLibraries_RequestSubscription) TakeMessage(out *ReloadControllerLibraries_Request) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneReloadControllerLibraries_RequestSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneReloadControllerLibraries_RequestSlice(dst, src []ReloadControllerLibraries_Request) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var ReloadControllerLibraries_RequestTypeSupport types.MessageTypeSupport = _ReloadControllerLibraries_RequestTypeSupport{}

type _ReloadControllerLibraries_RequestTypeSupport struct{}

func (t _ReloadControllerLibraries_RequestTypeSupport) New() types.Message {
	return NewReloadControllerLibraries_Request()
}

func (t _ReloadControllerLibraries_RequestTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.controller_manager_msgs__srv__ReloadControllerLibraries_Request
	return (unsafe.Pointer)(C.controller_manager_msgs__srv__ReloadControllerLibraries_Request__create())
}

func (t _ReloadControllerLibraries_RequestTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.controller_manager_msgs__srv__ReloadControllerLibraries_Request__destroy((*C.controller_manager_msgs__srv__ReloadControllerLibraries_Request)(pointer_to_free))
}

func (t _ReloadControllerLibraries_RequestTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*ReloadControllerLibraries_Request)
	mem := (*C.controller_manager_msgs__srv__ReloadControllerLibraries_Request)(dst)
	mem.force_kill = C.bool(m.ForceKill)
}

func (t _ReloadControllerLibraries_RequestTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*ReloadControllerLibraries_Request)
	mem := (*C.controller_manager_msgs__srv__ReloadControllerLibraries_Request)(ros2_message_buffer)
	m.ForceKill = bool(mem.force_kill)
}

func (t _ReloadControllerLibraries_RequestTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__controller_manager_msgs__srv__ReloadControllerLibraries_Request())
}

type CReloadControllerLibraries_Request = C.controller_manager_msgs__srv__ReloadControllerLibraries_Request
type CReloadControllerLibraries_Request__Sequence = C.controller_manager_msgs__srv__ReloadControllerLibraries_Request__Sequence

func ReloadControllerLibraries_Request__Sequence_to_Go(goSlice *[]ReloadControllerLibraries_Request, cSlice CReloadControllerLibraries_Request__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]ReloadControllerLibraries_Request, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		ReloadControllerLibraries_RequestTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func ReloadControllerLibraries_Request__Sequence_to_C(cSlice *CReloadControllerLibraries_Request__Sequence, goSlice []ReloadControllerLibraries_Request) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.controller_manager_msgs__srv__ReloadControllerLibraries_Request)(C.malloc(C.sizeof_struct_controller_manager_msgs__srv__ReloadControllerLibraries_Request * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		ReloadControllerLibraries_RequestTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func ReloadControllerLibraries_Request__Array_to_Go(goSlice []ReloadControllerLibraries_Request, cSlice []CReloadControllerLibraries_Request) {
	for i := 0; i < len(cSlice); i++ {
		ReloadControllerLibraries_RequestTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func ReloadControllerLibraries_Request__Array_to_C(cSlice []CReloadControllerLibraries_Request, goSlice []ReloadControllerLibraries_Request) {
	for i := 0; i < len(goSlice); i++ {
		ReloadControllerLibraries_RequestTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
