// Code generated by rclgo-gen. DO NOT EDIT.

package nav_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	geometry_msgs_msg "msgs/geometry_msgs/msg"
	std_msgs_msg "msgs/std_msgs/msg"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <nav_msgs/msg/goals.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("nav_msgs/Goals", GoalsTypeSupport)
	typemap.RegisterMessage("nav_msgs/msg/Goals", GoalsTypeSupport)
}

type Goals struct {
	Header std_msgs_msg.Header `yaml:"header"`// This header will store the time at which the poses were computed (not to be confused with the stamps of the poses themselves)In the case that individual poses do not have their frame_id set or their timetamp set they will use the default value here.
	Goals []geometry_msgs_msg.PoseStamped `yaml:"goals"`// An array of goals to for navigation to achieve.The goals should be executed in the order of the array.The header and stamp are intended to be used for computing the position of the goals.They may vary to support cases of goals that are moving with respect to the robot.
}

// NewGoals creates a new Goals with default values.
func NewGoals() *Goals {
	self := Goals{}
	self.SetDefaults()
	return &self
}

func (t *Goals) Clone() *Goals {
	c := &Goals{}
	c.Header = *t.Header.Clone()
	if t.Goals != nil {
		c.Goals = make([]geometry_msgs_msg.PoseStamped, len(t.Goals))
		geometry_msgs_msg.ClonePoseStampedSlice(c.Goals, t.Goals)
	}
	return c
}

func (t *Goals) CloneMsg() types.Message {
	return t.Clone()
}

func (t *Goals) SetDefaults() {
	t.Header.SetDefaults()
	t.Goals = nil
}

func (t *Goals) GetTypeSupport() types.MessageTypeSupport {
	return GoalsTypeSupport
}

// GoalsPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type GoalsPublisher struct {
	*rclgo.Publisher
}

// NewGoalsPublisher creates and returns a new publisher for the
// Goals
func NewGoalsPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*GoalsPublisher, error) {
	pub, err := node.NewPublisher(topic_name, GoalsTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &GoalsPublisher{pub}, nil
}

func (p *GoalsPublisher) Publish(msg *Goals) error {
	return p.Publisher.Publish(msg)
}

// GoalsSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type GoalsSubscription struct {
	*rclgo.Subscription
}

// GoalsSubscriptionCallback type is used to provide a subscription
// handler function for a GoalsSubscription.
type GoalsSubscriptionCallback func(msg *Goals, info *rclgo.MessageInfo, err error)

// NewGoalsSubscription creates and returns a new subscription for the
// Goals
func NewGoalsSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback GoalsSubscriptionCallback) (*GoalsSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg Goals
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, GoalsTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &GoalsSubscription{sub}, nil
}

func (s *GoalsSubscription) TakeMessage(out *Goals) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneGoalsSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneGoalsSlice(dst, src []Goals) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var GoalsTypeSupport types.MessageTypeSupport = _GoalsTypeSupport{}

type _GoalsTypeSupport struct{}

func (t _GoalsTypeSupport) New() types.Message {
	return NewGoals()
}

func (t _GoalsTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.nav_msgs__msg__Goals
	return (unsafe.Pointer)(C.nav_msgs__msg__Goals__create())
}

func (t _GoalsTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.nav_msgs__msg__Goals__destroy((*C.nav_msgs__msg__Goals)(pointer_to_free))
}

func (t _GoalsTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*Goals)
	mem := (*C.nav_msgs__msg__Goals)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	geometry_msgs_msg.PoseStamped__Sequence_to_C((*geometry_msgs_msg.CPoseStamped__Sequence)(unsafe.Pointer(&mem.goals)), m.Goals)
}

func (t _GoalsTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*Goals)
	mem := (*C.nav_msgs__msg__Goals)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	geometry_msgs_msg.PoseStamped__Sequence_to_Go(&m.Goals, *(*geometry_msgs_msg.CPoseStamped__Sequence)(unsafe.Pointer(&mem.goals)))
}

func (t _GoalsTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__nav_msgs__msg__Goals())
}

type CGoals = C.nav_msgs__msg__Goals
type CGoals__Sequence = C.nav_msgs__msg__Goals__Sequence

func Goals__Sequence_to_Go(goSlice *[]Goals, cSlice CGoals__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]Goals, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		GoalsTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func Goals__Sequence_to_C(cSlice *CGoals__Sequence, goSlice []Goals) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.nav_msgs__msg__Goals)(C.malloc(C.sizeof_struct_nav_msgs__msg__Goals * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		GoalsTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func Goals__Array_to_Go(goSlice []Goals, cSlice []CGoals) {
	for i := 0; i < len(cSlice); i++ {
		GoalsTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func Goals__Array_to_C(cSlice []CGoals, goSlice []Goals) {
	for i := 0; i < len(goSlice); i++ {
		GoalsTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
