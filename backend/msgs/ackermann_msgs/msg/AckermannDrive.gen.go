// Code generated by rclgo-gen. DO NOT EDIT.

package ackermann_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <ackermann_msgs/msg/ackermann_drive.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("ackermann_msgs/AckermannDrive", AckermannDriveTypeSupport)
	typemap.RegisterMessage("ackermann_msgs/msg/AckermannDrive", AckermannDriveTypeSupport)
}

type AckermannDrive struct {
	SteeringAngle float32 `yaml:"steering_angle"`// desired virtual angle (radians). Assumes Ackermann front-wheel steering. The left and right frontwheels are generally at different angles. To simplify, the commandedangle corresponds to the yaw of a virtual wheel located at thecenter of the front axle, like on a tricycle.  Positive yaw is tothe left. (This is *not* the angle of the steering wheel inside thepassenger compartment.)Zero steering angle velocity means change the steering angle asquickly as possible. Positive velocity indicates a desired absoluterate of change either left or right. The controller tries not toexceed this limit in either direction, but sometimes it might.
	SteeringAngleVelocity float32 `yaml:"steering_angle_velocity"`// desired rate of change (radians/s)
	Speed float32 `yaml:"speed"`// desired forward speed (m/s). Drive at requested speed, acceleration and jerk (the 1st, 2nd and3rd derivatives of position). All are measured at the vehicle'scenter of rotation, typically the center of the rear axle. Thecontroller tries not to exceed these limits in either direction, butsometimes it might.Speed is the desired scalar magnitude of the velocity vector.Direction is forward unless the sign is negative, indicating reverse.Zero acceleration means change speed as quickly aspossible. Positive acceleration indicates a desired absolutemagnitude; that includes deceleration.Zero jerk means change acceleration as quickly as possible. Positivejerk indicates a desired absolute rate of acceleration change ineither direction (increasing or decreasing).
	Acceleration float32 `yaml:"acceleration"`// desired acceleration (m/s^2)
	Jerk float32 `yaml:"jerk"`// desired jerk (m/s^3)
}

// NewAckermannDrive creates a new AckermannDrive with default values.
func NewAckermannDrive() *AckermannDrive {
	self := AckermannDrive{}
	self.SetDefaults()
	return &self
}

func (t *AckermannDrive) Clone() *AckermannDrive {
	c := &AckermannDrive{}
	c.SteeringAngle = t.SteeringAngle
	c.SteeringAngleVelocity = t.SteeringAngleVelocity
	c.Speed = t.Speed
	c.Acceleration = t.Acceleration
	c.Jerk = t.Jerk
	return c
}

func (t *AckermannDrive) CloneMsg() types.Message {
	return t.Clone()
}

func (t *AckermannDrive) SetDefaults() {
	t.SteeringAngle = 0
	t.SteeringAngleVelocity = 0
	t.Speed = 0
	t.Acceleration = 0
	t.Jerk = 0
}

func (t *AckermannDrive) GetTypeSupport() types.MessageTypeSupport {
	return AckermannDriveTypeSupport
}

// AckermannDrivePublisher wraps rclgo.Publisher to provide type safe helper
// functions
type AckermannDrivePublisher struct {
	*rclgo.Publisher
}

// NewAckermannDrivePublisher creates and returns a new publisher for the
// AckermannDrive
func NewAckermannDrivePublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*AckermannDrivePublisher, error) {
	pub, err := node.NewPublisher(topic_name, AckermannDriveTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &AckermannDrivePublisher{pub}, nil
}

func (p *AckermannDrivePublisher) Publish(msg *AckermannDrive) error {
	return p.Publisher.Publish(msg)
}

// AckermannDriveSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type AckermannDriveSubscription struct {
	*rclgo.Subscription
}

// AckermannDriveSubscriptionCallback type is used to provide a subscription
// handler function for a AckermannDriveSubscription.
type AckermannDriveSubscriptionCallback func(msg *AckermannDrive, info *rclgo.MessageInfo, err error)

// NewAckermannDriveSubscription creates and returns a new subscription for the
// AckermannDrive
func NewAckermannDriveSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback AckermannDriveSubscriptionCallback) (*AckermannDriveSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg AckermannDrive
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, AckermannDriveTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &AckermannDriveSubscription{sub}, nil
}

func (s *AckermannDriveSubscription) TakeMessage(out *AckermannDrive) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneAckermannDriveSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneAckermannDriveSlice(dst, src []AckermannDrive) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var AckermannDriveTypeSupport types.MessageTypeSupport = _AckermannDriveTypeSupport{}

type _AckermannDriveTypeSupport struct{}

func (t _AckermannDriveTypeSupport) New() types.Message {
	return NewAckermannDrive()
}

func (t _AckermannDriveTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.ackermann_msgs__msg__AckermannDrive
	return (unsafe.Pointer)(C.ackermann_msgs__msg__AckermannDrive__create())
}

func (t _AckermannDriveTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.ackermann_msgs__msg__AckermannDrive__destroy((*C.ackermann_msgs__msg__AckermannDrive)(pointer_to_free))
}

func (t _AckermannDriveTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*AckermannDrive)
	mem := (*C.ackermann_msgs__msg__AckermannDrive)(dst)
	mem.steering_angle = C.float(m.SteeringAngle)
	mem.steering_angle_velocity = C.float(m.SteeringAngleVelocity)
	mem.speed = C.float(m.Speed)
	mem.acceleration = C.float(m.Acceleration)
	mem.jerk = C.float(m.Jerk)
}

func (t _AckermannDriveTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*AckermannDrive)
	mem := (*C.ackermann_msgs__msg__AckermannDrive)(ros2_message_buffer)
	m.SteeringAngle = float32(mem.steering_angle)
	m.SteeringAngleVelocity = float32(mem.steering_angle_velocity)
	m.Speed = float32(mem.speed)
	m.Acceleration = float32(mem.acceleration)
	m.Jerk = float32(mem.jerk)
}

func (t _AckermannDriveTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__ackermann_msgs__msg__AckermannDrive())
}

type CAckermannDrive = C.ackermann_msgs__msg__AckermannDrive
type CAckermannDrive__Sequence = C.ackermann_msgs__msg__AckermannDrive__Sequence

func AckermannDrive__Sequence_to_Go(goSlice *[]AckermannDrive, cSlice CAckermannDrive__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]AckermannDrive, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		AckermannDriveTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func AckermannDrive__Sequence_to_C(cSlice *CAckermannDrive__Sequence, goSlice []AckermannDrive) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.ackermann_msgs__msg__AckermannDrive)(C.malloc(C.sizeof_struct_ackermann_msgs__msg__AckermannDrive * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		AckermannDriveTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func AckermannDrive__Array_to_Go(goSlice []AckermannDrive, cSlice []CAckermannDrive) {
	for i := 0; i < len(cSlice); i++ {
		AckermannDriveTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func AckermannDrive__Array_to_C(cSlice []CAckermannDrive, goSlice []AckermannDrive) {
	for i := 0; i < len(goSlice); i++ {
		AckermannDriveTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
