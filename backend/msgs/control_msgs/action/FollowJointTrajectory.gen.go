// Code generated by rclgo-gen. DO NOT EDIT.

package control_msgs_action

/*
#include <rosidl_runtime_c/message_type_support_struct.h>
#include <control_msgs/action/follow_joint_trajectory.h>
*/
import "C"

import (
	"context"
	"time"
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"

	action_msgs_msg "msgs/action_msgs/msg"
	action_msgs_srv "msgs/action_msgs/srv"
)

func init() {
	typemap.RegisterAction("control_msgs/FollowJointTrajectory", FollowJointTrajectoryTypeSupport)
	typemap.RegisterAction("control_msgs/action/FollowJointTrajectory", FollowJointTrajectoryTypeSupport)
}

type _FollowJointTrajectoryTypeSupport struct {}

func (s _FollowJointTrajectoryTypeSupport) Goal() types.MessageTypeSupport {
	return FollowJointTrajectory_GoalTypeSupport
}

func (s _FollowJointTrajectoryTypeSupport) SendGoal() types.ServiceTypeSupport {
	return FollowJointTrajectory_SendGoalTypeSupport
}

func (s _FollowJointTrajectoryTypeSupport) NewSendGoalResponse(accepted bool, stamp time.Duration) types.Message {
	msg := NewFollowJointTrajectory_SendGoal_Response()
	msg.Accepted = accepted
	secs := stamp.Truncate(time.Second)
	msg.Stamp.Sec = int32(secs)
	msg.Stamp.Nanosec = uint32(stamp - secs)
	return msg
}

func (s _FollowJointTrajectoryTypeSupport) Result() types.MessageTypeSupport {
	return FollowJointTrajectory_ResultTypeSupport
}

func (s _FollowJointTrajectoryTypeSupport) GetResult() types.ServiceTypeSupport {
	return FollowJointTrajectory_GetResultTypeSupport
}

func (s _FollowJointTrajectoryTypeSupport) NewGetResultResponse(status int8, result types.Message) types.Message {
	msg := NewFollowJointTrajectory_GetResult_Response()
	msg.Status = status
	if result == nil {
		msg.Result = *NewFollowJointTrajectory_Result()
	} else {
		msg.Result = *result.(*FollowJointTrajectory_Result)
	}
	return msg
}

func (s _FollowJointTrajectoryTypeSupport) CancelGoal() types.ServiceTypeSupport {
	return action_msgs_srv.CancelGoalTypeSupport
}

func (s _FollowJointTrajectoryTypeSupport) Feedback() types.MessageTypeSupport {
	return FollowJointTrajectory_FeedbackTypeSupport
}

func (s _FollowJointTrajectoryTypeSupport) FeedbackMessage() types.MessageTypeSupport {
	return FollowJointTrajectory_FeedbackMessageTypeSupport
}

func (s _FollowJointTrajectoryTypeSupport) NewFeedbackMessage(goalID *types.GoalID, feedback types.Message) types.Message {
	msg := NewFollowJointTrajectory_FeedbackMessage()
	msg.GoalID.Uuid = *goalID
	msg.Feedback = *feedback.(*FollowJointTrajectory_Feedback)
	return msg
}

func (s _FollowJointTrajectoryTypeSupport) GoalStatusArray() types.MessageTypeSupport {
	return action_msgs_msg.GoalStatusArrayTypeSupport
}

func (s _FollowJointTrajectoryTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_action_type_support_handle__control_msgs__action__FollowJointTrajectory())
}

// Modifying this variable is undefined behavior.
var FollowJointTrajectoryTypeSupport types.ActionTypeSupport = _FollowJointTrajectoryTypeSupport{}

type FollowJointTrajectoryFeedbackSender struct {
	sender rclgo.FeedbackSender
}

func (s *FollowJointTrajectoryFeedbackSender) Send(msg *FollowJointTrajectory_Feedback) error {
	return s.sender.Send(msg)
}

type FollowJointTrajectoryGoalHandle struct{
	*rclgo.GoalHandle

	Description *FollowJointTrajectory_Goal
}

func (g *FollowJointTrajectoryGoalHandle) Accept() (*FollowJointTrajectoryFeedbackSender, error) {
	s, err := g.GoalHandle.Accept()
	if err != nil {
		return nil, err
	}
	return &FollowJointTrajectoryFeedbackSender{*s}, nil
}

type FollowJointTrajectoryAction interface {
	ExecuteGoal(context.Context, *FollowJointTrajectoryGoalHandle) (*FollowJointTrajectory_Result, error)
}

func NewFollowJointTrajectoryAction(
	executeGoal func(context.Context, *FollowJointTrajectoryGoalHandle) (*FollowJointTrajectory_Result, error),
) FollowJointTrajectoryAction {
	return _FollowJointTrajectoryFuncAction(executeGoal)
}

type _FollowJointTrajectoryFuncAction func(context.Context, *FollowJointTrajectoryGoalHandle) (*FollowJointTrajectory_Result, error)

func (a _FollowJointTrajectoryFuncAction) ExecuteGoal(
	ctx context.Context, goal *FollowJointTrajectoryGoalHandle,
) (*FollowJointTrajectory_Result, error) {
	return a(ctx, goal)
}

type _FollowJointTrajectoryAction struct {
	action FollowJointTrajectoryAction
}

func (a _FollowJointTrajectoryAction) ExecuteGoal(ctx context.Context, handle *rclgo.GoalHandle) (types.Message, error) {
	return a.action.ExecuteGoal(ctx, &FollowJointTrajectoryGoalHandle{
		GoalHandle:  handle,
		Description: handle.Description.(*FollowJointTrajectory_Goal),
	})
}

func (a _FollowJointTrajectoryAction) TypeSupport() types.ActionTypeSupport {
	return FollowJointTrajectoryTypeSupport
}

type FollowJointTrajectoryServer struct{
	*rclgo.ActionServer
}

func NewFollowJointTrajectoryServer(node *rclgo.Node, name string, action FollowJointTrajectoryAction, opts *rclgo.ActionServerOptions) (*FollowJointTrajectoryServer, error) {
	server, err := node.NewActionServer(name, _FollowJointTrajectoryAction{action}, opts)
	if err != nil {
		return nil, err
	}
	return &FollowJointTrajectoryServer{server}, nil
}

type FollowJointTrajectoryFeedbackHandler func(context.Context, *FollowJointTrajectory_FeedbackMessage)

type FollowJointTrajectoryStatusHandler func(context.Context, *action_msgs_msg.GoalStatus)

type FollowJointTrajectoryClient struct{
	*rclgo.ActionClient
}

func NewFollowJointTrajectoryClient(node *rclgo.Node, name string, opts *rclgo.ActionClientOptions) (*FollowJointTrajectoryClient, error) {
	client, err := node.NewActionClient(name, FollowJointTrajectoryTypeSupport, opts)
	if err != nil {
		return nil, err
	}
	return &FollowJointTrajectoryClient{client}, nil
}

func (c *FollowJointTrajectoryClient) WatchGoal(ctx context.Context, goal *FollowJointTrajectory_Goal, onFeedback FollowJointTrajectoryFeedbackHandler) (*FollowJointTrajectory_GetResult_Response, *types.GoalID, error) {
	var resp types.Message
	var goalID *types.GoalID
	var err error
	if onFeedback == nil {
		resp, goalID, err = c.ActionClient.WatchGoal(ctx, goal, nil)
	} else {
		resp, goalID, err = c.ActionClient.WatchGoal(ctx, goal, func(ctx context.Context, msg types.Message) {
			onFeedback(ctx, msg.(*FollowJointTrajectory_FeedbackMessage))
		})
	}
	if r, ok := resp.(*FollowJointTrajectory_GetResult_Response); ok {
		return r, goalID, err
	}
	return nil, goalID, err
}

func (c *FollowJointTrajectoryClient) SendGoal(ctx context.Context, goal *FollowJointTrajectory_Goal) (*FollowJointTrajectory_SendGoal_Response, *types.GoalID, error) {
	resp, id, err := c.ActionClient.SendGoal(ctx, goal)
	if r, ok := resp.(*FollowJointTrajectory_SendGoal_Response); ok {
		return r, id, err
	}
	return nil, id, err
}

func (c *FollowJointTrajectoryClient) SendGoalRequest(ctx context.Context, request *FollowJointTrajectory_SendGoal_Request) (*FollowJointTrajectory_SendGoal_Response, error) {
	resp, err := c.ActionClient.SendGoalRequest(ctx, request)
	if r, ok := resp.(*FollowJointTrajectory_SendGoal_Response); ok {
		return r, err
	}
	return nil, err
}

func (c *FollowJointTrajectoryClient) GetResult(ctx context.Context, goalID *types.GoalID) (*FollowJointTrajectory_GetResult_Response, error) {
	resp, err := c.ActionClient.GetResult(ctx, goalID)
	if r, ok := resp.(*FollowJointTrajectory_GetResult_Response); ok {
		return r, err
	}
	return nil, err
}

func (c *FollowJointTrajectoryClient) CancelGoal(ctx context.Context, request *action_msgs_srv.CancelGoal_Request) (*action_msgs_srv.CancelGoal_Response, error) {
	resp, err := c.ActionClient.CancelGoal(ctx, request)
	if r, ok := resp.(*action_msgs_srv.CancelGoal_Response); ok {
		return r, err
	}
	return nil, err
}

func (c *FollowJointTrajectoryClient) WatchFeedback(ctx context.Context, goalID *types.GoalID, handler FollowJointTrajectoryFeedbackHandler) <-chan error {
	return c.ActionClient.WatchFeedback(ctx, goalID, func(ctx context.Context, msg types.Message) {
		handler(ctx, msg.(*FollowJointTrajectory_FeedbackMessage))
	})
}

func (c *FollowJointTrajectoryClient) WatchStatus(ctx context.Context, goalID *types.GoalID, handler FollowJointTrajectoryStatusHandler) <-chan error {
	return c.ActionClient.WatchStatus(ctx, goalID, func(ctx context.Context, msg types.Message) {
		handler(ctx, msg.(*action_msgs_msg.GoalStatus))
	})
}
