// Code generated by rclgo-gen. DO NOT EDIT.

package control_msgs_action
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	builtin_interfaces_msg "msgs/builtin_interfaces/msg"
	control_msgs_msg "msgs/control_msgs/msg"
	trajectory_msgs_msg "msgs/trajectory_msgs/msg"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <control_msgs/action/follow_joint_trajectory.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("control_msgs/FollowJointTrajectory_Goal", FollowJointTrajectory_GoalTypeSupport)
	typemap.RegisterMessage("control_msgs/action/FollowJointTrajectory_Goal", FollowJointTrajectory_GoalTypeSupport)
}

type FollowJointTrajectory_Goal struct {
	Trajectory trajectory_msgs_msg.JointTrajectory `yaml:"trajectory"`// The trajectory for all revolute, continuous or prismatic joints
	MultiDofTrajectory trajectory_msgs_msg.MultiDOFJointTrajectory `yaml:"multi_dof_trajectory"`// The trajectory for all planar or floating joints (i.e. individual joints with more than one DOF)
	PathTolerance []control_msgs_msg.JointTolerance `yaml:"path_tolerance"`// Tolerances applied to the joints as the trajectory is executed.  Ifviolated, the goal aborts with error_code set toPATH_TOLERANCE_VIOLATED.
	ComponentPathTolerance []control_msgs_msg.JointComponentTolerance `yaml:"component_path_tolerance"`
	GoalTolerance []control_msgs_msg.JointTolerance `yaml:"goal_tolerance"`// To report success, the joints must be within goal_tolerance of thefinal trajectory value.  The goal must be achieved by time thetrajectory ends plus goal_time_tolerance.  (goal_time_toleranceallows some leeway in time, so that the trajectory goal can stillsucceed even if the joints reach the goal some time after theprecise end time of the trajectory).If the joints are not within goal_tolerance after "trajectory finishtime" + goal_time_tolerance, the goal aborts with error_code set toGOAL_TOLERANCE_VIOLATED
	ComponentGoalTolerance []control_msgs_msg.JointComponentTolerance `yaml:"component_goal_tolerance"`
	GoalTimeTolerance builtin_interfaces_msg.Duration `yaml:"goal_time_tolerance"`
}

// NewFollowJointTrajectory_Goal creates a new FollowJointTrajectory_Goal with default values.
func NewFollowJointTrajectory_Goal() *FollowJointTrajectory_Goal {
	self := FollowJointTrajectory_Goal{}
	self.SetDefaults()
	return &self
}

func (t *FollowJointTrajectory_Goal) Clone() *FollowJointTrajectory_Goal {
	c := &FollowJointTrajectory_Goal{}
	c.Trajectory = *t.Trajectory.Clone()
	c.MultiDofTrajectory = *t.MultiDofTrajectory.Clone()
	if t.PathTolerance != nil {
		c.PathTolerance = make([]control_msgs_msg.JointTolerance, len(t.PathTolerance))
		control_msgs_msg.CloneJointToleranceSlice(c.PathTolerance, t.PathTolerance)
	}
	if t.ComponentPathTolerance != nil {
		c.ComponentPathTolerance = make([]control_msgs_msg.JointComponentTolerance, len(t.ComponentPathTolerance))
		control_msgs_msg.CloneJointComponentToleranceSlice(c.ComponentPathTolerance, t.ComponentPathTolerance)
	}
	if t.GoalTolerance != nil {
		c.GoalTolerance = make([]control_msgs_msg.JointTolerance, len(t.GoalTolerance))
		control_msgs_msg.CloneJointToleranceSlice(c.GoalTolerance, t.GoalTolerance)
	}
	if t.ComponentGoalTolerance != nil {
		c.ComponentGoalTolerance = make([]control_msgs_msg.JointComponentTolerance, len(t.ComponentGoalTolerance))
		control_msgs_msg.CloneJointComponentToleranceSlice(c.ComponentGoalTolerance, t.ComponentGoalTolerance)
	}
	c.GoalTimeTolerance = *t.GoalTimeTolerance.Clone()
	return c
}

func (t *FollowJointTrajectory_Goal) CloneMsg() types.Message {
	return t.Clone()
}

func (t *FollowJointTrajectory_Goal) SetDefaults() {
	t.Trajectory.SetDefaults()
	t.MultiDofTrajectory.SetDefaults()
	t.PathTolerance = nil
	t.ComponentPathTolerance = nil
	t.GoalTolerance = nil
	t.ComponentGoalTolerance = nil
	t.GoalTimeTolerance.SetDefaults()
}

func (t *FollowJointTrajectory_Goal) GetTypeSupport() types.MessageTypeSupport {
	return FollowJointTrajectory_GoalTypeSupport
}

// FollowJointTrajectory_GoalPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type FollowJointTrajectory_GoalPublisher struct {
	*rclgo.Publisher
}

// NewFollowJointTrajectory_GoalPublisher creates and returns a new publisher for the
// FollowJointTrajectory_Goal
func NewFollowJointTrajectory_GoalPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*FollowJointTrajectory_GoalPublisher, error) {
	pub, err := node.NewPublisher(topic_name, FollowJointTrajectory_GoalTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &FollowJointTrajectory_GoalPublisher{pub}, nil
}

func (p *FollowJointTrajectory_GoalPublisher) Publish(msg *FollowJointTrajectory_Goal) error {
	return p.Publisher.Publish(msg)
}

// FollowJointTrajectory_GoalSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type FollowJointTrajectory_GoalSubscription struct {
	*rclgo.Subscription
}

// FollowJointTrajectory_GoalSubscriptionCallback type is used to provide a subscription
// handler function for a FollowJointTrajectory_GoalSubscription.
type FollowJointTrajectory_GoalSubscriptionCallback func(msg *FollowJointTrajectory_Goal, info *rclgo.MessageInfo, err error)

// NewFollowJointTrajectory_GoalSubscription creates and returns a new subscription for the
// FollowJointTrajectory_Goal
func NewFollowJointTrajectory_GoalSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback FollowJointTrajectory_GoalSubscriptionCallback) (*FollowJointTrajectory_GoalSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg FollowJointTrajectory_Goal
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, FollowJointTrajectory_GoalTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &FollowJointTrajectory_GoalSubscription{sub}, nil
}

func (s *FollowJointTrajectory_GoalSubscription) TakeMessage(out *FollowJointTrajectory_Goal) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneFollowJointTrajectory_GoalSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneFollowJointTrajectory_GoalSlice(dst, src []FollowJointTrajectory_Goal) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var FollowJointTrajectory_GoalTypeSupport types.MessageTypeSupport = _FollowJointTrajectory_GoalTypeSupport{}

type _FollowJointTrajectory_GoalTypeSupport struct{}

func (t _FollowJointTrajectory_GoalTypeSupport) New() types.Message {
	return NewFollowJointTrajectory_Goal()
}

func (t _FollowJointTrajectory_GoalTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.control_msgs__action__FollowJointTrajectory_Goal
	return (unsafe.Pointer)(C.control_msgs__action__FollowJointTrajectory_Goal__create())
}

func (t _FollowJointTrajectory_GoalTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.control_msgs__action__FollowJointTrajectory_Goal__destroy((*C.control_msgs__action__FollowJointTrajectory_Goal)(pointer_to_free))
}

func (t _FollowJointTrajectory_GoalTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*FollowJointTrajectory_Goal)
	mem := (*C.control_msgs__action__FollowJointTrajectory_Goal)(dst)
	trajectory_msgs_msg.JointTrajectoryTypeSupport.AsCStruct(unsafe.Pointer(&mem.trajectory), &m.Trajectory)
	trajectory_msgs_msg.MultiDOFJointTrajectoryTypeSupport.AsCStruct(unsafe.Pointer(&mem.multi_dof_trajectory), &m.MultiDofTrajectory)
	control_msgs_msg.JointTolerance__Sequence_to_C((*control_msgs_msg.CJointTolerance__Sequence)(unsafe.Pointer(&mem.path_tolerance)), m.PathTolerance)
	control_msgs_msg.JointComponentTolerance__Sequence_to_C((*control_msgs_msg.CJointComponentTolerance__Sequence)(unsafe.Pointer(&mem.component_path_tolerance)), m.ComponentPathTolerance)
	control_msgs_msg.JointTolerance__Sequence_to_C((*control_msgs_msg.CJointTolerance__Sequence)(unsafe.Pointer(&mem.goal_tolerance)), m.GoalTolerance)
	control_msgs_msg.JointComponentTolerance__Sequence_to_C((*control_msgs_msg.CJointComponentTolerance__Sequence)(unsafe.Pointer(&mem.component_goal_tolerance)), m.ComponentGoalTolerance)
	builtin_interfaces_msg.DurationTypeSupport.AsCStruct(unsafe.Pointer(&mem.goal_time_tolerance), &m.GoalTimeTolerance)
}

func (t _FollowJointTrajectory_GoalTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*FollowJointTrajectory_Goal)
	mem := (*C.control_msgs__action__FollowJointTrajectory_Goal)(ros2_message_buffer)
	trajectory_msgs_msg.JointTrajectoryTypeSupport.AsGoStruct(&m.Trajectory, unsafe.Pointer(&mem.trajectory))
	trajectory_msgs_msg.MultiDOFJointTrajectoryTypeSupport.AsGoStruct(&m.MultiDofTrajectory, unsafe.Pointer(&mem.multi_dof_trajectory))
	control_msgs_msg.JointTolerance__Sequence_to_Go(&m.PathTolerance, *(*control_msgs_msg.CJointTolerance__Sequence)(unsafe.Pointer(&mem.path_tolerance)))
	control_msgs_msg.JointComponentTolerance__Sequence_to_Go(&m.ComponentPathTolerance, *(*control_msgs_msg.CJointComponentTolerance__Sequence)(unsafe.Pointer(&mem.component_path_tolerance)))
	control_msgs_msg.JointTolerance__Sequence_to_Go(&m.GoalTolerance, *(*control_msgs_msg.CJointTolerance__Sequence)(unsafe.Pointer(&mem.goal_tolerance)))
	control_msgs_msg.JointComponentTolerance__Sequence_to_Go(&m.ComponentGoalTolerance, *(*control_msgs_msg.CJointComponentTolerance__Sequence)(unsafe.Pointer(&mem.component_goal_tolerance)))
	builtin_interfaces_msg.DurationTypeSupport.AsGoStruct(&m.GoalTimeTolerance, unsafe.Pointer(&mem.goal_time_tolerance))
}

func (t _FollowJointTrajectory_GoalTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__FollowJointTrajectory_Goal())
}

type CFollowJointTrajectory_Goal = C.control_msgs__action__FollowJointTrajectory_Goal
type CFollowJointTrajectory_Goal__Sequence = C.control_msgs__action__FollowJointTrajectory_Goal__Sequence

func FollowJointTrajectory_Goal__Sequence_to_Go(goSlice *[]FollowJointTrajectory_Goal, cSlice CFollowJointTrajectory_Goal__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]FollowJointTrajectory_Goal, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		FollowJointTrajectory_GoalTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func FollowJointTrajectory_Goal__Sequence_to_C(cSlice *CFollowJointTrajectory_Goal__Sequence, goSlice []FollowJointTrajectory_Goal) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.control_msgs__action__FollowJointTrajectory_Goal)(C.malloc(C.sizeof_struct_control_msgs__action__FollowJointTrajectory_Goal * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		FollowJointTrajectory_GoalTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func FollowJointTrajectory_Goal__Array_to_Go(goSlice []FollowJointTrajectory_Goal, cSlice []CFollowJointTrajectory_Goal) {
	for i := 0; i < len(cSlice); i++ {
		FollowJointTrajectory_GoalTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func FollowJointTrajectory_Goal__Array_to_C(cSlice []CFollowJointTrajectory_Goal, goSlice []FollowJointTrajectory_Goal) {
	for i := 0; i < len(goSlice); i++ {
		FollowJointTrajectory_GoalTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
